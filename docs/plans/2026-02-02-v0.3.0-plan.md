# iShell v0.3.0 å®æ–½è®¡åˆ’

**Goal:** å®ç° iShell v0.3.0 çš„æ ¸å¿ƒåŠŸèƒ½å¢å¼ºï¼ŒåŒ…æ‹¬ SFTP æ–‡ä»¶ä¼ è¾“ã€çœŸå®ç³»ç»Ÿç›‘æ§ã€å‘½ä»¤å†å²ã€è®¾ç½®ç•Œé¢å’Œä¸»é¢˜åˆ‡æ¢ï¼Œä½¿ iShell æˆä¸ºåŠŸèƒ½å®Œæ•´çš„ SSH ç®¡ç†å·¥å…·ã€‚

**Version:** v0.2.0 â†’ v0.3.0  
**Target Date:** 2026-02-10 (8 å¤©)  
**Estimated Effort:** çº¦ 20-25 å°æ—¶

---

## ğŸ“‹ åŠŸèƒ½æ¸…å•

### æ ¸å¿ƒåŠŸèƒ½
1. âœ¨ **SFTP æ–‡ä»¶ä¼ è¾“** - æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½ã€ç›®å½•æµè§ˆã€æ‹–æ”¾æ”¯æŒ
2. ğŸ“Š **çœŸå®ç³»ç»Ÿç›‘æ§** - æ›¿æ¢æ¨¡æ‹Ÿæ•°æ®ï¼Œæ˜¾ç¤ºçœŸå® CPU/å†…å­˜/ç£ç›˜/ç½‘ç»œ
3. ğŸ” **å‘½ä»¤å†å²æœç´¢** - ä¿å­˜å†å²ã€æ¨¡ç³Šæœç´¢ã€å¿«æ·é”®è°ƒç”¨
4. âš™ï¸ **è®¾ç½®ç•Œé¢** - ç»Ÿä¸€è®¾ç½®é¢æ¿ï¼Œç®¡ç†æ‰€æœ‰é…ç½®
5. ğŸ¨ **ä¸»é¢˜åˆ‡æ¢** - æ·±è‰²/æµ…è‰²ä¸»é¢˜ï¼Œè‡ªå®šä¹‰é¢œè‰²

### é¢å¤–åŠŸèƒ½
6. ğŸ’¾ **æ–‡ä»¶ç³»ç»Ÿæ”¯æŒ** - æœ¬åœ°/è¿œç¨‹æ–‡ä»¶æµè§ˆå™¨æ•´åˆ

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ–°å¢æ¨¡å—

```
src/
â”œâ”€â”€ sftp.rs           # SFTP å®¢æˆ·ç«¯å®ç°
â”œâ”€â”€ monitor.rs        # ç³»ç»Ÿç›‘æ§ï¼ˆä½¿ç”¨ sysinfoï¼‰
â”œâ”€â”€ history.rs        # å‘½ä»¤å†å²ç®¡ç†
â”œâ”€â”€ settings.rs       # è®¾ç½®ç®¡ç†
â”œâ”€â”€ theme.rs          # ä¸»é¢˜ç³»ç»Ÿ
â””â”€â”€ ui/
    â”œâ”€â”€ file_browser.rs    # æ–‡ä»¶æµè§ˆå™¨ UI
    â”œâ”€â”€ settings_panel.rs  # è®¾ç½®é¢æ¿ UI
    â””â”€â”€ (ç°æœ‰ panels.rs)
```

### ä¾èµ–æ›´æ–°

```toml
[dependencies]
# ç°æœ‰ä¾èµ– (ä¿æŒ)
# ... ssh2, tokio, egui, serde, toml ...

# æ–°å¢ä¾èµ–
sysinfo = "0.30"           # ç³»ç»Ÿç›‘æ§
rfd = "0.12"               # æ–‡ä»¶å¯¹è¯æ¡†
fuzzy-matcher = "0.3"      # æ¨¡ç³Šæœç´¢
```

---

## ğŸ“¦ Phase 1: SFTP æ–‡ä»¶ä¼ è¾“ (é«˜ä¼˜å…ˆçº§)

**é¢„è®¡æ—¶é—´:** 8-10 å°æ—¶

### Task 1.1: SFTP æ¨¡å—åŸºç¡€

**Files:**
- Create: `src/sftp.rs`
- Modify: `src/types.rs` (æ·»åŠ  SFTP ç±»å‹)
- Modify: `src/state/mod.rs` (æ·»åŠ  SFTP çŠ¶æ€)

**Step 1: å®šä¹‰ SFTP ç±»å‹**

åœ¨ `src/types.rs` æ·»åŠ ï¼š

```rust
#[derive(Debug, Clone)]
pub struct FileEntry {
    pub name: String,
    pub path: String,
    pub is_dir: bool,
    pub size: u64,
    pub modified: Option<SystemTime>,
    pub permissions: Option<String>,
}

#[derive(Debug, Clone)]
pub enum SftpOperation {
    Upload { local_path: PathBuf, remote_path: String },
    Download { remote_path: String, local_path: PathBuf },
    List { path: String },
    Delete { path: String },
    CreateDir { path: String },
}

#[derive(Debug, Clone)]
pub enum SftpMessage {
    FileList(Vec<FileEntry>),
    Progress(f32),
    Complete,
    Error(String),
}
```

**Step 2: å®ç° SFTP å®¢æˆ·ç«¯**

åˆ›å»º `src/sftp.rs`:

```rust
use ssh2::Sftp as Ssh2Sftp;
use std::path::Path;

pub struct SftpClient {
    sftp: Ssh2Sftp,
}

impl SftpClient {
    pub fn new(sftp: Ssh2Sftp) -> Self {
        Self { sftp }
    }
    
    pub fn list_dir(&self, path: &str) -> Result<Vec<FileEntry>, Error> {
        // åˆ—å‡ºç›®å½•å†…å®¹
    }
    
    pub fn upload_file(&self, local: &Path, remote: &str, progress_callback: impl Fn(f32)) -> Result<(), Error> {
        // ä¸Šä¼ æ–‡ä»¶ï¼ŒæŠ¥å‘Šè¿›åº¦
    }
    
    pub fn download_file(&self, remote: &str, local: &Path, progress_callback: impl Fn(f32)) -> Result<(), Error> {
        // ä¸‹è½½æ–‡ä»¶ï¼ŒæŠ¥å‘Šè¿›åº¦
    }
    
    pub fn delete(&self, path: &str) -> Result<(), Error> {
        // åˆ é™¤æ–‡ä»¶/ç›®å½•
    }
    
    pub fn create_dir(&self, path: &str) -> Result<(), Error> {
        // åˆ›å»ºç›®å½•
    }
}
```

**Step 3: é›†æˆåˆ° SSH ä¼šè¯**

ä¿®æ”¹ `src/ssh.rs`ï¼Œæ·»åŠ  SFTP æ”¯æŒï¼š

```rust
impl SshSession {
    pub fn sftp(&self) -> Result<SftpClient, Error> {
        if let Some(sess) = &self.session {
            let sftp = sess.sftp()?;
            Ok(SftpClient::new(sftp))
        } else {
            Err("Not connected".into())
        }
    }
}
```

**Verification:**
```bash
cargo test sftp::tests
```

---

### Task 1.2: SFTP UI é¢æ¿

**Files:**
- Create: `src/ui/file_browser.rs`
- Modify: `src/app.rs` (æ·»åŠ æ–‡ä»¶æµè§ˆå™¨é¢æ¿)

**Step 1: åˆ›å»ºæ–‡ä»¶æµè§ˆå™¨ UI**

åˆ›å»º `src/ui/file_browser.rs`:

```rust
pub fn render_file_browser(state: &mut AppState, ctx: &egui::Context) {
    egui::SidePanel::right("file_browser")
        .resizable(true)
        .default_width(400.0)
        .show(ctx, |ui| {
            ui.heading("ğŸ“ File Browser");
            ui.separator();
            
            // è·¯å¾„å¯¼èˆª
            ui.horizontal(|ui| {
                ui.label("Path:");
                ui.text_edit_singleline(&mut state.current_remote_path);
                if ui.button("ğŸ”„").clicked() {
                    // åˆ·æ–°ç›®å½•
                }
            });
            
            ui.separator();
            
            // æ–‡ä»¶åˆ—è¡¨ï¼ˆåŒåˆ—ï¼šæœ¬åœ° | è¿œç¨‹ï¼‰
            ui.columns(2, |cols| {
                // æœ¬åœ°æ–‡ä»¶
                cols[0].vertical(|ui| {
                    ui.label("ğŸ’» Local");
                    // æœ¬åœ°æ–‡ä»¶åˆ—è¡¨
                });
                
                // è¿œç¨‹æ–‡ä»¶
                cols[1].vertical(|ui| {
                    ui.label("â˜ï¸ Remote");
                    // è¿œç¨‹æ–‡ä»¶åˆ—è¡¨
                });
            });
            
            ui.separator();
            
            // æ“ä½œæŒ‰é’®
            ui.horizontal(|ui| {
                if ui.button("â¬†ï¸ Upload").clicked() {
                    // ä¸Šä¼ æ–‡ä»¶
                }
                if ui.button("â¬‡ï¸ Download").clicked() {
                    // ä¸‹è½½æ–‡ä»¶
                }
                if ui.button("ğŸ—‘ï¸ Delete").clicked() {
                    // åˆ é™¤æ–‡ä»¶
                }
                if ui.button("ğŸ“ New Folder").clicked() {
                    // åˆ›å»ºç›®å½•
                }
            });
            
            // è¿›åº¦æ¡
            if state.sftp_progress > 0.0 {
                ui.add(egui::ProgressBar::new(state.sftp_progress));
            }
        });
}
```

**Step 2: æ·»åŠ æ‹–æ”¾æ”¯æŒ**

åœ¨ `file_browser.rs` ä¸­æ·»åŠ ï¼š

```rust
// åœ¨æ–‡ä»¶åˆ—è¡¨åŒºåŸŸæ£€æµ‹æ‹–æ”¾
if ui.input(|i| !i.raw.dropped_files.is_empty()) {
    let files = ui.input(|i| i.raw.dropped_files.clone());
    for file in files {
        if let Some(path) = file.path {
            // ä¸Šä¼ æ‹–æ”¾çš„æ–‡ä»¶
            state.upload_files.push(path);
        }
    }
}
```

**Verification:**
- æ‰‹åŠ¨æµ‹è¯•ï¼šå¯åŠ¨åº”ç”¨ï¼Œæ‰“å¼€æ–‡ä»¶æµè§ˆå™¨ï¼Œæµè§ˆè¿œç¨‹ç›®å½•

---

## ğŸ“Š Phase 2: çœŸå®ç³»ç»Ÿç›‘æ§ (ä¸­ä¼˜å…ˆçº§)

**é¢„è®¡æ—¶é—´:** 4-5 å°æ—¶

### Task 2.1: ç³»ç»Ÿç›‘æ§æ¨¡å—

**Files:**
- Create: `src/monitor.rs`
- Modify: `Cargo.toml` (æ·»åŠ  sysinfo ä¾èµ–)
- Modify: `src/ui/panels.rs` (æ›´æ–°ç›‘æ§é¢æ¿)

**Step 1: æ·»åŠ  sysinfo ä¾èµ–**

```toml
[dependencies]
sysinfo = "0.30"
```

**Step 2: å®ç°ç›‘æ§æ¨¡å—**

åˆ›å»º `src/monitor.rs`:

```rust
use sysinfo::{System, SystemExt, CpuExt, DiskExt, NetworkExt};

pub struct SystemMonitor {
    system: System,
}

impl SystemMonitor {
    pub fn new() -> Self {
        Self {
            system: System::new_all(),
        }
    }
    
    pub fn update(&mut self) {
        self.system.refresh_all();
    }
    
    pub fn cpu_usage(&self) -> f32 {
        self.system.global_cpu_info().cpu_usage()
    }
    
    pub fn memory_usage(&self) -> (u64, u64) {
        (self.system.used_memory(), self.system.total_memory())
    }
    
    pub fn disk_usage(&self) -> Vec<(String, u64, u64)> {
        self.system.disks().iter().map(|disk| {
            (
                disk.mount_point().to_string_lossy().to_string(),
                disk.total_space() - disk.available_space(),
                disk.total_space(),
            )
        }).collect()
    }
    
    pub fn network_usage(&self) -> (u64, u64) {
        let networks = self.system.networks();
        let received: u64 = networks.iter().map(|(_, n)| n.received()).sum();
        let transmitted: u64 = networks.iter().map(|(_, n)| n.transmitted()).sum();
        (received, transmitted)
    }
}
```

**Step 3: é›†æˆåˆ°åº”ç”¨çŠ¶æ€**

ä¿®æ”¹ `src/state/mod.rs`:

```rust
pub struct AppState {
    // ... ç°æœ‰å­—æ®µ ...
    
    // ç³»ç»Ÿç›‘æ§
    pub system_monitor: Option<SystemMonitor>,
    pub last_monitor_update: std::time::Instant,
}
```

**Step 4: æ›´æ–°ç›‘æ§é¢æ¿ UI**

ä¿®æ”¹ `src/ui/panels.rs` ä¸­çš„ `render_monitor_panel`:

```rust
pub fn render_monitor_panel(state: &mut AppState, ctx: &egui::Context) {
    // æ¯ç§’æ›´æ–°ä¸€æ¬¡
    if state.last_monitor_update.elapsed() > Duration::from_secs(1) {
        if let Some(monitor) = &mut state.system_monitor {
            monitor.update();
            state.last_monitor_update = std::time::Instant::now();
        }
    }
    
    egui::TopBottomPanel::bottom("monitor")
        .show(ctx, |ui| {
            if let Some(monitor) = &state.system_monitor {
                let cpu = monitor.cpu_usage();
                let (mem_used, mem_total) = monitor.memory_usage();
                let mem_percent = (mem_used as f32 / mem_total as f32) * 100.0;
                
                ui.columns(4, |cols| {
                    // CPU
                    cols[0].vertical(|ui| {
                        ui.label(egui::RichText::new("ğŸ”¥ CPU").strong());
                        ui.add(egui::ProgressBar::new(cpu / 100.0)
                            .text(format!("{:.1}%", cpu)));
                    });
                    
                    // Memory
                    cols[1].vertical(|ui| {
                        ui.label(egui::RichText::new("ğŸ’¾ Memory").strong());
                        ui.add(egui::ProgressBar::new(mem_percent / 100.0)
                            .text(format!("{:.1}%", mem_percent)));
                        ui.label(format!("{:.1} GB / {:.1} GB", 
                            mem_used as f32 / 1024.0 / 1024.0 / 1024.0,
                            mem_total as f32 / 1024.0 / 1024.0 / 1024.0));
                    });
                    
                    // Disk (æ˜¾ç¤ºç¬¬ä¸€ä¸ªç£ç›˜)
                    // Network
                });
            }
        });
}
```

**Verification:**
```bash
cargo run
# æ£€æŸ¥ç›‘æ§é¢æ¿æ˜¾ç¤ºçœŸå®æ•°æ®
```

---

## ğŸ” Phase 3: å‘½ä»¤å†å²æœç´¢ (ä¸­ä¼˜å…ˆçº§)

**é¢„è®¡æ—¶é—´:** 3-4 å°æ—¶

### Task 3.1: å†å²æ¨¡å—

**Files:**
- Create: `src/history.rs`
- Modify: `src/state/mod.rs`
- Modify: `src/ui/panels.rs` (ç»ˆç«¯é¢æ¿)

**Step 1: å®ç°å‘½ä»¤å†å²**

åˆ›å»º `src/history.rs`:

```rust
use serde::{Serialize, Deserialize};
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommandHistory {
    pub commands: Vec<HistoryEntry>,
    max_size: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryEntry {
    pub command: String,
    pub timestamp: String,
    pub connection: String,
}

impl CommandHistory {
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
            max_size: 1000,
        }
    }
    
    pub fn add(&mut self, command: String, connection: String) {
        let entry = HistoryEntry {
            command,
            timestamp: chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
            connection,
        };
        
        self.commands.push(entry);
        
        // ä¿æŒæœ€å¤§å¤§å°
        if self.commands.len() > self.max_size {
            self.commands.remove(0);
        }
    }
    
    pub fn search(&self, query: &str) -> Vec<&HistoryEntry> {
        use fuzzy_matcher::FuzzyMatcher;
        use fuzzy_matcher::skim::SkimMatcherV2;
        
        let matcher = SkimMatcherV2::default();
        let mut results: Vec<(&HistoryEntry, i64)> = self.commands
            .iter()
            .filter_map(|entry| {
                matcher.fuzzy_match(&entry.command, query)
                    .map(|score| (entry, score))
            })
            .collect();
        
        results.sort_by(|a, b| b.1.cmp(&a.1));
        results.into_iter().map(|(entry, _)| entry).collect()
    }
    
    pub fn save(&self, path: &PathBuf) -> Result<(), std::io::Error> {
        let content = serde_json::to_string_pretty(self)?;
        std::fs::write(path, content)
    }
    
    pub fn load(path: &PathBuf) -> Result<Self, std::io::Error> {
        let content = std::fs::read_to_string(path)?;
        Ok(serde_json::from_str(&content)?)
    }
}
```

**Step 2: é›†æˆåˆ°åº”ç”¨**

ä¿®æ”¹ `src/state/mod.rs`:

```rust
pub struct AppState {
    // ... ç°æœ‰å­—æ®µ ...
    
    // å‘½ä»¤å†å²
    pub command_history: CommandHistory,
    pub show_history_search: bool,
    pub history_search_query: String,
}
```

**Step 3: æ·»åŠ å†å²æœç´¢ UI**

åœ¨ `src/ui/panels.rs` çš„ç»ˆç«¯é¢æ¿æ·»åŠ ï¼š

```rust
// åœ¨ç»ˆç«¯é¢æ¿é¡¶éƒ¨æ·»åŠ å†å²æœç´¢æŒ‰é’®
if ui.button("ğŸ” History (Ctrl+R)").clicked() || 
   ui.input(|i| i.key_pressed(egui::Key::R) && i.modifiers.ctrl) {
    state.show_history_search = !state.show_history_search;
}

// å†å²æœç´¢å¯¹è¯æ¡†
if state.show_history_search {
    egui::Window::new("ğŸ” Command History")
        .collapsible(false)
        .show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.label("Search:");
                let resp = ui.text_edit_singleline(&mut state.history_search_query);
                resp.request_focus();
            });
            
            ui.separator();
            
            let results = state.command_history.search(&state.history_search_            
            egui::ScrollArea::vertical()
                .max_height(300.0)
                .show(ui, i| {
                    for entry in results.iter().take(20) {
                        if ui.selectable_label(false, &entrymand).clicked() {
                            state.command_input = entry.command.clone();
                    state.show_history_search = false;
                        }
                        ui.label(egui::RichTextw(
                            format!("{} - {}", entry.timestamp, entry.connection)
                 ).small().weak());
                        ui.separator();
                    }
                });
        });
}
```

**Verification:**
- æ‰‹åŠ¨æµ‹è¯•ï¼šæ‰§è¡Œå‡ æ¡å‘½ä»¤ï¼ŒæŒ‰ Ctrl+R æœç´¢å†å²

---

## âš™ï¸ Phase 4: è®¾ç½®ç•Œé¢ (ä¸­ä¼˜å…ˆçº§)

**é¢„è®¡æ—¶é—´:** 4-5 å°æ—¶

### Task 4.1: è®¾ç½®ç®¡ç†æ¨¡å—

**Files:**
- Create: `src/settings.rs`
- Create: `src/ui/settings_panel.rs`
- Modify: `src/types.rs`

**Steå±•è®¾ç½®ç±»å‹**

åœ¨ `src/types.rs` æ·»åŠ ï¼š

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppSettings {
    // å¤–è§‚
    pub theme: Theme,
    pub font_size: f32,
    pub terminal_font_size: f32,
   / è¡Œä¸º
    pub default_ai_provider: AiProviderType,
    pub auto_save_config: bool,
    pub confirm_before_delete: bool,
    
    // ç»ˆç«¯
    pub terminal_scrollback: usize,
  inal_word_wrap: bool,
    
    // å¿«æ·é”®
    pub keybindings: HashMap<String, String>,
}

impl DefaulpSettings {
    fn default() -> Self {
        Self {
            theme: Theme::Dark,
            font_size: 14.0,
            t_font_size: 14.0,
            default_ai_provider: AiProviderType::Ollama,
            auto_save_config: true,
            confirm_before_delen            terminal_scrollback: 10000,
            terminal_word_wrap: false,
            keybindings: Self::default_keybindings(),
        }
    }
}
```

**Step 2: åˆ›å»ºè®¾ç½®é¢æ¿ UI**

åˆ›å»º `src/ui/settings_panel.rs`:

```rust
pub fn render_settings_window(state: &mut AppState, cgui::Context) {
    if !state.show_settings {
        return;
    }
    
    egui::Window::new("âš™ï¸ Settings")
 efault_width(600.0)
        .default_height(500.0)
        .show(ctx, |ui| {
            egui::SidePanel::left("settings_menu")
                .resizable(false)
                .exact_width(150.0)
                .show_inside(ui, |ui| {
               ui.selectable_value(&mut state.settings_page, SettingsPage::General, "ğŸ¨ General");
                   ble_value(&mut state.settings_page, SettingsPage::Appearance, "ğŸ–Œï¸ Appearance");
                    ui.selectable_value(&m.settings_page, SettingsPage::Terminal, "ğŸ’» Terminal");
                    ui.selectable_value(&mut state.settings_page, SettingsPage::Ai, "ğŸ¤– AI");
                    ui.selectable_value(&mut ss_page, SettingsPage::Keybindings, "âŒ¨ï¸ Keybindings");
                });
            
            egui::CentralPanel::default().show_inside(ui, |ui| {
                match state.settings_page {
                    SettingsPage::General => render_general_settings(state, ui),
                    SettingsPage::Appearance => render_appearance_settings(state, ui),
                    SettingsPage::Terminal => render_terminal_settings(state, ui),
                    SettingsPage::Ai => render_ai_settings(state, ui),
                    SettingsPage::Keybindings => render_keybindings_settings(state, ui),
                }
            });
            
            ui.separator();
            
            ui.horizontal(|ui| {
                if ui.button("âœ… Save").clicked() {
                    save_config(state);
                    state.show_settings = false;
                }
                if ui.button("âŒ Cancel").clicked() {
                    state.show_settings = false;
                }
                if ui.button("ğŸ”„ Reset to Defaults").clicked() {
                    state.config.settings = AppSettings::default();
                }
            });
        });
}

fn render_general_settings(state: &mut AppState, ui: &mut egui::Ui) {
    ui.heading("General Settings");
    ui.separator();
    
    ui.checkbox(&mut state.config.settings.auto_save_config, "Auto-save configuration");
    ui.checkbox(&mut state.config.settings.confirm_before_delete, "Confirm before deleting");
    
    // æ›´å¤šé€šç”¨è®¾ç½®...
}

fn render_appearance_settings(state: &mut AppState, ui: &mut egui::Ui) {
    ui.heading("Appearance");
    ui.separator();
    
    ui.horizontal(|ui| {
        ui.label("Theme:");
        ui.selectable_value(&mut state.config.settings.theme, Theme::Dark, "ğŸŒ™ Dark");
        ui.selectable_value(&mut state.config.settings.theme, Theme::Light, "â˜€ï¸ Light");
    });
    
    ui.add(egui::Slider::new(&mut state.config.settings.font_size, 10.0..=24.0).text("Font Size"));
    ui.add(egui::Slider::new(&mut state.config.settings.terminal_font_size, 10.0..=24.0).text("Terminal Font Size"));
}

// ... å…¶ä»–è®¾ç½®é¡µé¢ ...
```

**Verification:**
- æ‰‹åŠ¨æµ‹è¯•ï¼šæ‰“å¼€è®¾ç½®ï¼Œä¿®æ”¹é…ç½®ï¼Œä¿å­˜å¹¶é‡å¯éªŒè¯

---

## ğŸ¨ Phase 5: ä¸»é¢˜åˆ‡æ¢ (ä½ä¼˜å…ˆçº§)

**é¢„è®¡æ—¶é—´:** 3-4 å°æ—¶

### Task 5.1: ä¸»é¢˜ç³»ç»Ÿ

**Files:**
- Create: `src/theme.rs`
- Modify: `src/types.rs`
- Modify: `src/app.rs`

**Step 1: å®šä¹‰ä¸»é¢˜**

åˆ›å»º `src/theme.rs`:

```rust
use egui::{Color32, Visuals, Style};

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum Theme {
    Dark,
    Light,
    Custom,
}

pub struct ThemeManager;

impl ThemeManager {
    pub fn apply(ctx: &egui::Context, theme: Theme) {
        match theme {
            Theme::Dark => ctx.set_visuals(egui::Visuals::dark()),
            Theme::Light => ctx.set_visuals(egui::Visuals::light()),
            Theme::Custom => ctx.set_visuals(Self::custom_theme()),
        }
    }
    
    fn custom_theme() -> Visuals {
        let mut visuals = Visuals::dark();
        
        // è‡ªå®šä¹‰é¢œè‰²
        visuals.widgets.noninteractive.bg_fill = Color32::from_rgb(30, 30, 40);
        visuals.widgets.inactive.bg_fill = Color32::from_rgb(40, 40, 50);
        visuals.widgets.hovered.bg_fill = Color32::from_rgb(50, 50, 70);
        visuals.widgets.active.bg_fill = Color32::from_rgb(60, 60, 90);
        
        visuals.selection.bg_fill = Color32::from_rgb(100, 149, 237);
        
        visuals
    }
}
```

**Step 2: é›†æˆä¸»é¢˜åˆ‡æ¢**

åœ¨ `src/app.rs` çš„ `update` æ–¹æ³•ä¸­ï¼š

```rust
impl eframe::App for App {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // åº”ç”¨ä¸»é¢˜
        ThemeManager::apply(ctx, self.config.settings.theme);
        
        // ... å…¶ä½™ä»£ç  ...
    }
}
```

**Verification:**
- æ‰‹åŠ¨æµ‹è¯•ï¼šåˆ‡æ¢ä¸»é¢˜ï¼Œæ£€æŸ¥ UI é¢œè‰²å˜åŒ–

---

## ğŸ’¾ Phase 6: æ–‡ä»¶ç³»ç»Ÿæ”¯æŒ (å¯é€‰)

**é¢„è®¡æ—¶é—´:** 2-3 å°æ—¶

### Task 6.1: æœ¬åœ°æ–‡ä»¶æµè§ˆå™¨

**Files:**
- Modify: `src/ui/file_browser.rs`
- Add: `rfd` dependency

**Step 1: æ·»åŠ æ–‡ä»¶å¯¹è¯æ¡†**

```toml
[dependencies]
rfd = "0.12"  # Native file dialog
```

**Step 2: å®ç°æœ¬åœ°æ–‡ä»¶æµè§ˆ**

åœ¨ `file_browser.rs` ä¸­æ·»åŠ ï¼š

```rust
// æœ¬åœ°æ–‡ä»¶æµè§ˆ
fn render_local_files(state: &mut AppState, ui: &mut egui::Ui) {
    if ui.button("ğŸ“‚ Browse...").clicked() {
        if let Some(path) = rfd::FileDialog::new().pick_folder() {
            state.local_current_path = path;
        }
    }
    
    // åˆ—å‡ºå½“å‰ç›®å½•
    if let Ok(entries) = std::fs::read_dir(&state.local_current_path) {
        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                let name = path.file_name().unwrap().to_string_lossy();
                let is_dir = path.is_dir();
                
                let icon = if is_dir { "ğŸ“" } else { "ğŸ“„" };
                
                if ui.selectable_label(false, format!("{} {}", icon, name)).clicked() {
                    if is_dir {
                        state.local_current_path = path;
                    } else {
                        // é€‰ä¸­æ–‡ä»¶
                        state.selected_local_file = Some(path);
                    }
                }
            }
        }
    }
}
```

---

## ğŸ“‹ ä»»åŠ¡ä¼˜å…ˆçº§æ€»ç»“

| Phase | åŠŸèƒ½ | ä¼˜å…ˆçº§ | æ—¶é—´ | ä¾èµ– |
|-------|------|--------|------|------|
| 1 | SFTP æ–‡ä»¶ä¼ è¾“ | é«˜ | 8-10h | ssh2 |
| 2 | çœŸå®ç³»ç»Ÿç›‘æ§ | ä¸­ | 4-5h | sysinfo |
| 3 | å‘½ä»¤å†å²æœç´¢ | ä¸­ | 3-4h | fuzzy-matcher |
| 4 | è®¾ç½®ç•Œé¢ | ä¸­ | 4-5h | - |
| 5 | ä¸»é¢˜åˆ‡æ¢ | ä½ | 3-4h | - |
| 6 | æ–‡ä»¶ç³»ç»Ÿæ”¯æŒ | å¯é€‰ | 2-3h | rfd |

**æ€»è®¡**: 24-31 å°æ—¶

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
- SFTP æ“ä½œæµ‹è¯•
- å†å²æœç´¢æµ‹è¯•
- è®¾ç½®åºåˆ—åŒ–/ååºåˆ—åŒ–æµ‹è¯•

### é›†æˆæµ‹è¯•
- SFTP ä¸Šä¼ /ä¸‹è½½æµç¨‹
- ç³»ç»Ÿç›‘æ§æ•°æ®è·å–
- ä¸»é¢˜åˆ‡æ¢æ•ˆæœ

### æ‰‹åŠ¨æµ‹è¯•
- UI äº¤äº’æµ‹è¯•
- æ–‡ä»¶æ‹–æ”¾æµ‹è¯•
- å¿«æ·é”®æµ‹è¯•

---

## ğŸ“… å¼€å‘æ—¶é—´è¡¨

### Week 1 (Day 1-4)
- Day 1-2: Phase 1 (SFTP åŸºç¡€)
- Day 3: Phase 2 (ç³»ç»Ÿç›‘æ§)
- Day 4: Phase 3 (å‘½ä»¤å†å²)

### Week 2 (Day 5-8)
- Day 5: Phase 4 (è®¾ç½®ç•Œé¢)
- Day 6: Phase 5 (ä¸»é¢˜åˆ‡æ¢)
- Day 7: Phase 6 (æ–‡ä»¶ç³»ç»Ÿï¼Œå¯é€‰)
- Day 8: æµ‹è¯•ã€ä¿®å¤ã€æ–‡æ¡£æ›´æ–°

---

## éªŒæ”¶æ ‡å‡†

### Must Have âœ…
- [ ] SFTP æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½åŠŸèƒ½
- [ ] çœŸå®ç³»ç»Ÿç›‘æ§æ•°æ®æ˜¾ç¤º
- [ ] å‘½ä»¤å†å²ä¿å­˜å’Œæœç´¢
- [ ] è®¾ç½®ç•Œé¢å¯ç”¨
- [ ] ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] æ–‡æ¡£æ›´æ–°

### Should Have
- [ ] SFTP æ‹–æ”¾æ”¯æŒ
- [ ] è¿›åº¦æ¡æ˜¾ç¤º
- [ ] å¿«æ·é”®æ”¯æŒ
- [ ] æ€§èƒ½ä¼˜åŒ–

### Nice to Have
- [ ] æœ¬åœ°æ–‡ä»¶æµè§ˆå™¨
- [ ] è‡ªå®šä¹‰ä¸»é¢˜
- [ ] æ‰¹é‡æ–‡ä»¶æ“ä½œ

---

**åˆ›å»ºæ—¥æœŸ**: 2026-02-02  
**ç›®æ ‡ç‰ˆæœ¬**: v0.3.0  
**é¢„è®¡å‘å¸ƒ**: 2026-02-10
