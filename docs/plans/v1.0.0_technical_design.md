# iShell v1.0.0 æŠ€æœ¯è®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **ç‰ˆæœ¬**: 1.0
- **æ—¥æœŸ**: 2026-02-03
- **çŠ¶æ€**: è®¾è®¡é˜¶æ®µ
- **ä½œè€…**: iShell å¼€å‘å›¢é˜Ÿ

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### å½“å‰æ¶æ„ (v0.3.0)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Main App                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         AppState                   â”‚ â”‚
â”‚  â”‚  - Single SSH Session              â”‚ â”‚
â”‚  â”‚  - Terminal Output                 â”‚ â”‚
â”‚  â”‚  - AI Manager                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         UI Panels                  â”‚ â”‚
â”‚  â”‚  - Connections                     â”‚ â”‚
â”‚  â”‚  - Terminal                        â”‚ â”‚
â”‚  â”‚  - AI Assistant                    â”‚ â”‚
â”‚  â”‚  - Monitor                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç›®æ ‡æ¶æ„ (v1.0.0)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Main App                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              TabManager                             â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚  â”‚
â”‚  â”‚  â”‚ Tab 1    â”‚ â”‚ Tab 2    â”‚ â”‚ Tab 3    â”‚ ...       â”‚  â”‚
â”‚  â”‚  â”‚ SessionA â”‚ â”‚ SessionB â”‚ â”‚ SessionC â”‚           â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              PluginManager                          â”‚  â”‚
â”‚  â”‚  [Plugin1] [Plugin2] [Plugin3] ...                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚          PortForwardManager                         â”‚  â”‚
â”‚  â”‚  Local: [8080â†’db:3306]                             â”‚  â”‚
â”‚  â”‚  Remote: [9000â†’local:8000]                         â”‚  â”‚
â”‚  â”‚  Dynamic: [SOCKS5:1080]                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Phase 1: å¤šæ ‡ç­¾é¡µç³»ç»Ÿ

### 1.1 æ•°æ®ç»“æ„è®¾è®¡

#### TabManager
```rust
// src/tabs/manager.rs
use std::sync::{Arc, RwLock};
use std::collections::HashMap;

pub struct TabManager {
    /// æ‰€æœ‰æ ‡ç­¾é¡µ
    tabs: Vec<Tab>,
    
    /// å½“å‰æ¿€æ´»çš„æ ‡ç­¾é¡µç´¢ active_tab_index: usize,
    
    /// ä¸‹ä¸€ä¸ªæ ‡ç­¾ IDï¼ˆè‡ªå¢ï¼‰
    next_tab_id: usize,
    
    /// æ ‡ç­¾é¡µæœ€å¤§æ•°é‡é™åˆ¶
    max_tabs: usize,
}

impl TabManager {
    pub fn new() -> Self {
        let mut manager = Self {
            tabs: Vec::new(),
            active_tab_index: 0,
            next_tab_id: 1,
            max_tabs: 50,
        };
        
        // é»˜è®¤åˆ›å»ºä¸€ä¸ªæ ‡ç­¾é¡µ
        manager.create_tab("Tab 1".to_string(), None);
        manager
    }
    
    /// åˆ›å»ºæ–°æ ‡ç­¾é¡µ
    pub fn create_tab(&mut self, title: String, connection_id: Option<usize>) -> usize {
        if self.tabs.len() >= self.max_tabs {
            eprintln!("è¾¾åˆ°æ ‡ç­¾é¡µæ•°é‡é™åˆ¶");
            return self.active_tab_index;
        }
        
        let tab_id = self.next_tab_id;
        self.next_tab_id += 1;
        
        let tab = Tab::new(tab_id, title, connection_id);
        self.tabs.push(tab);
        
        // åˆ‡æ¢åˆ°æ–°æ ‡ç­¾
        self.active_tab_index = self.tabs.len() - 1;
        
        tab_id
    }
    
    /// å…³é—­æ ‡ç­¾é¡µ
    pub fn close_tab(&mut self, index: usize) -> bool {
        if self.tabs.len() <= 1 {
            // è‡³å°‘ä¿ç•™ä¸€ä¸ªæ ‡ç­¾é¡µ
            return false;
        }
        
        if index < self.tabs.len() {
            self.tabs.remove(index);
            
            // è°ƒæ•´æ´»è·ƒæ ‡ç­¾ç´¢å¼•
            if self.active_tab_index >= self.tabs.len() {
                self.active_tab_index = self.tabs.len() - 1;
            }
            
            true
        } else {       false
        }
    }
    
    /// åˆ‡æ¢åˆ°æŒ‡å®šæ ‡ç­¾
    pub fn switch_to(&mut self, index: usize) {
        if index < self.tabs.len() {
            self.active_tab_index = index;
        }
    }
    
    /// è·å–å½“å‰æ´»è·ƒæ ‡ç­¾
    pub fn active_tab(&self) -> Option<&Tab> {
        self.tabs.get(self.active_tab_index)
    }
    
    /// è·å–å½“å‰æ´»è·ƒæ ‡ç­¾ï¼ˆå¯å˜ï¼‰
    pub fn active_tab_mut(&mut self) -> Option<&mut Tab> {
        self.tabs.get_mut(self.active_tab_index)
    }
    
    /// åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ ‡ç­¾ï¼ˆCtrl+Tabï¼‰
    pub fn next_tab(&mut self) {
        if !self.tabs.is_empty() {
            self.active_tab_index = (self.active_tab_index + 1) % self.tabs.len();
        }
    }
    
    /// åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªæ ‡ç­¾ï¼ˆCtrl+Shift+Tabï¼‰
    pub fn previous_tab(&mut self) {
        if !self.tabs.is_empty() {
            self.active_tab_index = if self.active_tab_index == 0 {
                self.tabs.len() - 1
            } else {
                self.active_tab_index - 1
            };
        }
    }
}
```

#### Tab
```rust
// src/tabs/tab.rs
use std::time::SystemTime;
use crate::state::TabState;

pub struct Tab {
    /// å”¯ä¸€ ID
    pub id: usize,
    
    /// æ ‡ç­¾æ ‡é¢˜
    pub title: String,
    
    /// è¿æ¥ IDï¼ˆå¦‚æœå·²è¿æ¥ï¼‰
    pub connection_id: Option<usize>,
    
    /// æ ‡ç­¾é¡µçŠ¶æ€
    pub state: TabState,
    
    /// åˆ›å»ºæ—¶é—´
    pub created_at: SystemTime,
    
    /// æœ€åæ´»è·ƒæ—¶é—´
    pub last_active: SystemTime,
}

impl Tab {
    pub fn new(id: usize, title: String, connection_id: Option<usize>) -> Self {
        Self {
            id,
            title,
            connection_id,
            state: TabState::new(),
            created_at: SystemTime::now(),
            last_active: SystemTime::now(),
        }
    }
    
    /// æ ‡è®°ä¸ºæ´»è·ƒ
    pub fn mark_active(&mut self) {
        self.last_active = SystemTime::now();
    }
    
    /// æ›´æ–°æ ‡é¢˜
    pub fn set_title(&mut self, title: String) {
        self.title = title;
    }
    
    /// è¿æ¥åˆ°æœåŠ¡å™¨
    pub fn connect(&mut self, connection_id: usize) {
        self.connection_id = Some(connection_id);
        self.title = format!("Connected ({})", connection_id);
    }
    
    /// æ–­å¼€è¿æ¥
    pub fn disconnect(&mut self) {
        self.connection_id = None;
        self.title = format!("Tab {}", self.id);
    }
}
```

#### TabState
```rust
// src/state/tab_state.rs
use crate::ssh::SshSession;
use crate::history::CommandHistory;
use std::sync::Arc;

/// æ¯ä¸ªæ ‡ç­¾é¡µçš„ç‹¬ç«‹çŠ¶æ€
pub struct TabState {
    /// SSH ä¼šè¯
    pub ssh_session: Option<Arc<std::sync::Mutex<SshSession>>>,
    
    /// ç»ˆç«¯è¾“å‡ºç¼“å†²åŒº
    pub terminal_output: String,
    
    /// å‘½ä»¤è¾“å…¥
    pub command_input: String,
    
    /// å‘½ä»¤å†å²
    pub command_history: CommandHistory,
    
    /// SFTP çŠ¶æ€
    pub sftp_state: Option<SftpTabState>,
    
    /// AI å¯¹è¯å†å²
    pub ai_messages: Vec<(String, String)>,
    
    /// AI è¾“å…¥
    pub ai_input: String,
}

impl TabState {
    pub fn new() -> Self {
        Self {
            ssh_session: None,
            terminal_output: String::new(),
            command_input: String::new(),
            command_history: CommandHistory::new(),
            sftp_state: None,
            ai_messages: Vec::new(),
            ai_input: String::new(),
        }
    }
}

pub struct SftpTabState {
    pub remote_path: String,
    pub remote_files: Vec<FileEntry>,
    pub selected_files: Vec<String>,
}
```

### 1.2 UI é›†æˆ

#### æ ‡ç­¾æ æ¸²æŸ“
```rust
// src/ui/tab_bar.rs
use crate::tabs::TabManager;
use egui::Context;

pub fn render_tab_bar(tab_manager: &mut TabManager, ctx: &Context) {
    egui::TopBottomPanel::top("tab_bar")
        .exact_height(35.0)
        .show(ctx, |ui| {
            ui.horizontal(|ui| {
                // æ¸²æŸ“æ‰€æœ‰æ ‡ç­¾
                let mut tab_to_close = None;
                let mut tab_to_switch = None;
                
                for (index, tab) in tab_manager.tabs.iter().enumerate() {
                    let is_active = index == tab_manager.active_tab_index;
                    
                    // æ ‡ç­¾æŒ‰é’®
                    let color = if is_active {
                        egui::Color32::from_rgb(100, 149, 237)
                    } else {
                        egui::Color32::from_rgb(60, 60, 70)
                    };
                    
                    ui.scope(|ui| {
                        ui.visuals_mut().widgets.inactive.bg_fill = color;
                        
                        let response = ui.button(&tab.title);
                        
                        if response.clicked() {
                            tab_to_switch = Some(index);
                        }
                        
                        // å³é”®èœå•
                        response.context_menu(|ui| {
                            if ui.button("âœï¸ é‡å‘½å").clicked() {
                                // TODO: æ˜¾ç¤ºé‡å‘½åå¯¹è¯æ¡†
                                ui.close_menu();
                            }
                            if ui.button("ğŸ“‹ å¤åˆ¶").clicked() {
                                // TODO: å¤åˆ¶æ ‡ç­¾
                                ui.close_menu();
                            }
                            ui.separator();
                            if ui.button("âŒ å…³é—­").clicked() {
                                tab_to_close = Some(index);
                                ui.close_menu();
                            }
                        });
                        
                        // å…³é—­æŒ‰é’®
                        if tab_manager.tabs.len() > 1 {
                            if ui.small_button("Ã—").clicked() {
                                tab_to_close = Some(index);
                            }
                        }
                    });
                }
                
                // æ–°å»ºæ ‡ç­¾æŒ‰é’®
                if ui.button("â•").clicked() {
                    tab_manager.create_tab(
                        format!("Tab {}", tab_manager.next_tab_id),
                        None
                    );
                }
                
                // å¤„ç†æ“ä½œ
                if let Some(index) = tab_to_close {
                    tab_manager.close_tab(index);
                }
                if let Some(index) = tab_to_switch {
                    tab_manager.switch_to(index);
                }
            });
        });
}
```

#### å¿«æ·é”®å¤„ç†
```rust
// src/ui/keyboard.rs
use egui::{Context, Key, Modifiers};

pub fn handle_tab_shortcuts(tab_manager: &mut TabManager, ctx: &Context) {
    ctx.input(|i| {
        let ctrl = i.modifiers.ctrl;
        let shift = i.modifiers.shift;
        
        // Ctrl+T: æ–°å»ºæ ‡ç­¾
        if ctrl && i.key_pressed(Key::T) {
            tab_manager.create_tab(
                format!("Tab {}", tab_manager.next_tab_id),
                None
            );
        }
        
        // Ctrl+W: å…³é—­æ ‡ç­¾
        if ctrl && i.key_pressed(Key::W) {
            tab_manager.close_tab(tab_manager.active_tab_index);
        }
        
        // Ctrl+Tab: ä¸‹ä¸€ä¸ªæ ‡ç­¾
        if ctrl && i.key_pressed(Key::Tab) && !shift {
            tab_manager.next_tab();
        }
        
        // Ctrl+Shift+Tab: ä¸Šä¸€ä¸ªæ ‡ç­¾
        if ctrl && shift && i.key_pressed(Key::Tab) {
            tab_manager.previous_tab();
        }
        
        // Ctrl+1-9: å¿«é€Ÿåˆ‡æ¢
        for (n, key) in [
            (1, Key::Num1), (2, Key::Num2), (3, Key::Num3),
            (4, Key::Num4), (5, Key::Num5), (6, Key::Num6),
            (7, Key::Num7), (8, Key::Num8), (9, Key::Num9),
        ] {
            if ctrl && i.key_pressed(key) {
                if n <= tab_manager.tabs.len() {
                    tab_manager.switch_to(n - 1);
                }
            }
        }
    });
}
```

### 1.3 çŠ¶æ€ç®¡ç†

#### AppState é‡æ„
```rust
// src/state/mod.rs
pub struct AppState {
    // å…¨å±€é…ç½®
    pub config_manager: ConfigManager,
    pub config: AppConfig,
    pub runtime: Arc<tokio::runtime::Runtime>,
    
    // æ ‡ç­¾ç®¡ç†å™¨ï¼ˆæ–°å¢ï¼‰
    pub tab_manager: TabManager,
    
    // å…¨å±€ UI çŠ¶æ€
    pub show_new_connection: bool,
    pub show_settings: bool,
    pub show_plugin_manager: bool,  // æ–°å¢
    pub show_port_forward: bool,    // æ–°å¢
    
    // è¿æ¥åˆ—è¡¨ï¼ˆå…¨å±€å…±äº«ï¼‰
    pub connections: Vec<SshConfig>,
    
    // AI Managerï¼ˆå…¨å±€å…±äº«ï¼‰
    pub ai_manager: Arc<TokioMutex<Option<AiManager>>>,
    
    // ç³»ç»Ÿç›‘æ§ï¼ˆå…¨å±€å…±äº«ï¼‰
    pub system_monitor: Arc<SystemMonitor>,
    
    // æ’ä»¶ç®¡ç†å™¨ï¼ˆæ–°å¢ï¼‰
    pub plugin_manager: PluginManager,
    
    // ç«¯å£è½¬å‘ç®¡ç†å™¨ï¼ˆæ–°å¢ï¼‰
    pub port_forward_manager: PortForwardManager,
}
```

---

## ğŸ”Œ Phase 2: ç«¯å£è½¬å‘ç³»ç»Ÿ

### 2.1 æ•°æ®ç»“æ„

```rust
// src/port_forward/mod.rs
use std::net::TcpListener;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct PortForwardManager {
    forwards: Vec<ForwardHandle>,
    next_id: usize,
}

pub enum ForwardType {
    Local(LocalForward),
    Remote(RemoteForward),
    Dynamic(DynamicForward),
}

pub struct LocalForward {
    pub id: usize,
    pub local_host: String,
    pub local_port: u16,
    pub remote_host: String,
    pub remote_port: u16,
    pub status: ForwardStatus,
}

pub struct RemoteForward {
    pub id: usize,
    pub remote_host: String,
    pub remote_port: u16,
    pub local_host: String,
    pub local_port: u16,
    pub status: ForwardStatus,
}

pub struct DynamicForward {
    pub id: usize,
    pub local_host: String,
    pub local_port: u16,
    pub status: ForwardStatus,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ForwardStatus {
    Active,
    Inactive,
    Error,
}

pub struct ForwardHandle {
    pub forward_type: ForwardType,
    pub stop_signal: Arc<Mutex<bool>>,
    pub thread_handle: Option<std::thread::JoinHandle<()>>,
}
```

### 2.2 æœ¬åœ°ç«¯å£è½¬å‘å®ç°

```rust
// src/port_forward/local.rs
use ssh2::Channel;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};

impl LocalForward {
    pub fn start(
        &mut self,
        session: Arc<Mutex<SshSession>>,
    ) -> Result<()> {
        let listener = TcpListener::bind(
            format!("{}:{}", self.local_host, self.local_port)
        )?;
        
        let remote_host = self.remote_host.clone();
        let remote_port = self.remote_port;
        
        std::thread::spawn(move || {
            for stream in listener.incoming() {
                match stream {
                    Ok(local_stream) => {
                        let session = session.clone();
                        let remote_host = remote_host.clone();
                        
                        // ä¸ºæ¯ä¸ªè¿æ¥åˆ›å»ºæ–°çº¿ç¨‹
                        std::thread::spawn(move || {
                            if let Err(e) = handle_local_forward(
                                local_stream,
                                session,
                                &remote_host,
                                remote_port,
                            ) {
                                eprintln!("è½¬å‘é”™è¯¯: {}", e);
                            }
                        });
                    }
                    Err(e) => eprintln!("æ¥å—è¿æ¥å¤±è´¥: {}", e),
                }
            }
        });
        
        self.status = ForwardStatus::Active;
        Ok(())
    }
}

fn handle_local_forward(
    mut local_stream: TcpStream,
    session: Arc<Mutex<SshSession>>,
    remote_host: &str,
    remote_port: u16,
) -> Result<()> {
    // å»ºç«‹åˆ°è¿œç¨‹ä¸»æœºçš„é€šé“
    let mut channel = {
        let sess = session.lock().unwrap();
        sess.session.channel_direct_tcpip(
            remote_host,
            remote_port,
            None,
        )?
    };
    
    // åŒå‘æ•°æ®è½¬å‘
    let mut local_buf = [0u8; 8192];
    let mut remote_buf = [0u8; 8192];
    
    loop {
        // ä»æœ¬åœ°è¯»å–ï¼Œå‘é€åˆ°è¿œç¨‹
        match local_stream.read(&mut local_buf) {
            Ok(0) => break,  // è¿æ¥å…³é—­
            Ok(n) => {
                channel.write_all(&local_buf[..n])?;
            }
            Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {}
            Err(e) => return Err(e.into()),
        }
        
        // ä»è¿œç¨‹è¯»å–ï¼Œå‘é€åˆ°æœ¬åœ°
        match channel.read(&mut remote_buf) {
            Ok(0) => break,
            Ok(n) => {
                local_stream.write_all(&remote_buf[..n])?;
            }
            Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {}
            Err(e) => return Err(e.into()),
        }
    }
    
    Ok(())
}
```

### 2.3 åŠ¨æ€ç«¯å£è½¬å‘ï¼ˆSOCKS5ï¼‰

```rust
// src/port_forward/dynamic.rs
use tokio::net::TcpListener;
use tokio_socks::tcp::Socks5Stream;

impl DynamicForward {
    pub async fn start(
        &mut self,
        session: Arc<Mutex<SshSession>>,
    ) -> Result<()> {
        let listener = TcpListener::bind(
            format!("{}:{}", self.local_host, self.local_port)
        ).await?;
        
        tokio::spawn(async move {
            loop {
                match listener.accept().await {
                    Ok((stream, _addr)) => {
                        let session = session.clone();
                        tokio::spawn(handle_socks5_connection(stream, session));
                    }
                    Err(e) => eprintln!("SOCKS5 accept error: {}", e),
                }
            }
        });
        
        self.status = ForwardStatus::Active;
        Ok(())
    }
}

async fn handle_socks5_connection(
    stream: tokio::net::TcpStream,
    session: Arc<Mutex<SshSession>>,
) -> Result<()> {
    // å®ç° SOCKS5 æ¡æ‰‹
    // 1. å®¢æˆ·ç«¯é—®å€™
    // 2. æœåŠ¡å™¨é€‰æ‹©è®¤è¯æ–¹æ³•
    // 3. å®¢æˆ·ç«¯è¯·æ±‚
    // 4. æœåŠ¡å™¨å“åº”
    // 5. æ•°æ®è½¬å‘
    
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨ tokio-socks åº“ç®€åŒ–å®ç°
    Ok(())
}
```

---

## ğŸ”— Phase 3: SSH ä»£ç†æ”¯æŒ

### 3.1 ProxyConfig æ‰©å±•

```rust
// src/types.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyConfig {
    /// è·³æ¿æœºåœ°å€
    pub jump_host: String,
    
    /// è·³æ¿æœºç«¯å£
    pub jump_port: u16,
    
    /// è·³æ¿æœºç”¨æˆ·å
    pub jump_username: String,
    
    /// è·³æ¿æœºè®¤è¯
    pub jump_auth: AuthMethod,
    
    /// å¤šçº§è·³æ¿æœºï¼ˆå¯é€‰ï¼‰
    pub next_proxy: Option<Box<ProxyConfig>>,
}

impl SshConfig {
    pub fn with_proxy(mut self, proxy: ProxyConfig) -> Self {
        self.proxy = Some(proxy);
        self
    }
}
```

### 3.2 é€šè¿‡è·³æ¿æœºè¿æ¥

```rust
// src/ssh.rs
impl SshSession {
    pub fn connect_via_proxy(&mut self, proxy: &ProxyConfig) -> Result<()> {
        // é€’å½’å¤„ç†å¤šçº§è·³æ¿
        let tcp_stream = if let Some(next_proxy) = &proxy.next_proxy {
            self.connect_via_proxy(next_proxy)?
        } else {
            TcpStream::connect(format!("{}:{}", proxy.jump_host, proxy.jump_port))?
        };
        
        // åœ¨è·³æ¿æœºä¸Šå»ºç«‹ SSH ä¼šè¯
        let mut jump_session = Session::new()?;
        jump_session.set_tcp_stream(tcp_stream);
        jump_session.handshake()?;
        
        // è®¤è¯è·³æ¿æœº
        match &proxy.jump_auth {
            AuthMethod::Password(pwd) => {
                jump_session.userauth_password(&proxy.jump_username, pwd)?;
            }
            AuthMethod::PrivateKey { key_path, passphrase } => {
                jump_session.userauth_pubkey_file(
                    &proxy.jump_username,
                    None,
                    key_path,
                    passphrase.as_deref(),
                )?;
            }
        }
        
        // é€šè¿‡è·³æ¿æœºå»ºç«‹åˆ°ç›®æ ‡æœåŠ¡å™¨çš„é€šé“
        let channel = jump_session.channel_direct_tcpip(
            &self.host,
            self.port,
            None,
        )?;
        
        // åœ¨é€šé“ä¸Šå»ºç«‹ç›®æ ‡æœåŠ¡å™¨çš„ SSH ä¼šè¯
        let mut target_session = Session::new()?;
        target_session.set_tcp_stream(channel);
        target_session.handshake()?;
        
        // è®¤è¯ç›®æ ‡æœåŠ¡å™¨
        if let Some(auth) = &self.auth {
            match auth {
                AuthMethod::Password(pwd) => {
                    target_session.userauth_password(&self.username, pwd)?;
                }
                AuthMethod::PrivateKey { key_path, passphrase } => {
                    target_session.userauth_pubkey_file(
                        &self.username,
                        None,
                        key_path,
                        passphrase.as_deref(),
                    )?;
                }
            }
        }
        
        self.session = target_session;
        self.proxy_session = Some(Arc::new(Mutex::new(jump_session)));
        
        Ok(())
    }
}
```

---

## ğŸ§© Phase 4: æ’ä»¶ç³»ç»Ÿ

### 4.1 æ’ä»¶æ¥å£

```rust
// src/plugin/trait.rs
use egui::Context;

pub trait Plugin: Send + Sync {
    /// æ’ä»¶å…ƒæ•°æ®
    fn metadata(&self) -> PluginMetadata;
    
    /// æ’ä»¶åŠ è½½æ—¶è°ƒç”¨
    fn on_load(&mut self, context: &PluginContext) -> Result<()>;
    
    /// æ’ä»¶å¸è½½æ—¶è°ƒç”¨
    fn on_unload(&mut self) -> Result<()>;
    
    /// å¤„ç†å‘½ä»¤ï¼ˆè¿”å› Some è¡¨ç¤ºå‘½ä»¤è¢«å¤„ç†ï¼‰
    fn on_command(&mut self, command: &str, args: &[&str]) -> Option<String> {
        None
    }
    
    /// è¿‡æ»¤ SSH è¾“å‡º
    fn on_ssh_output(&mut self, output: &str) -> Option<String> {
        None
    }
    
    /// æ¸²æŸ“æ’ä»¶ UI
    fn render_ui(&mut self, ui: &mut egui::Ui, ctx: &PluginContext) {}
    
    /// å¤„ç†å¿«æ·é”®
    fn on_key_press(&mut self, key: egui::Key, modifiers: egui::Modifiers) -> bool {
        false
    }
}

#[derive(Debug, Clone)]
pub struct PluginMetadata {
    pub name: String,
    pub version: String,
    pub author: String,
    pub description: String,
    pub capabilities: Vec<PluginCapability>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum PluginCapability {
    CommandHandler,
    OutputFilter,
    UiPanel,
    KeyBinding,
}

pub struct PluginContext {
    pub app_version: String,
    pub config_dir: PathBuf,
    pub data_dir: PathBuf,
}
```

### 4.2 æ’ä»¶åŠ è½½å™¨

```rust
// src/plugin/loader.rs
use libloading::{Library, Symbol};

pub struct PluginLoader {
    plugin_dir: PathBuf,
    loaded_libraries: Vec<Library>,
}

impl PluginLoader {
    pub fn load_from_dylib(&mut self, path: &Path) -> Result<Box<dyn Plugin>> {
        unsafe {
            let lib = Library::new(path)?;
            
            // æŸ¥æ‰¾æ’ä»¶å…¥å£ç‚¹
            let create_plugin: Symbol<fn() -> *mut dyn Plugin> = 
                lib.get(b"create_plugin")?;
            
            let plugin_ptr = create_plugin();
            let plugin = Box::from_raw(plugin_ptr);
            
            self.loaded_libraries.push(lib);
            
            Ok(plugin)
        }
    }
    
    pub fn load_from_wasm(&mut self, path: &Path) -> Result<Box<dyn Plugin>> {
        // ä½¿ç”¨ wasmer åŠ è½½ WebAssembly æ’ä»¶
        let wasm_bytes = std::fs::read(path)?;
        let store = Store::default();
        let module = Module::new(&store, wasm_bytes)?;
        
        // ... å®ä¾‹åŒ–å’ŒåŒ…è£…ä¸º Plugin trait
        
        todo!("WebAssembly plugin support")
    }
}

// æ’ä»¶å¿…é¡»å¯¼å‡ºè¿™ä¸ªå‡½æ•°
#[no_mangle]
pub extern "C" fn create_plugin() -> *mut dyn Plugin {
    Box::into_raw(Box::new(MyPlugin::new()))
}
```

### 4.3 ç¤ºä¾‹æ’ä»¶

```rust
// plugins/json_formatter/src/lib.rs
use ishell_plugin::*;

pub struct JsonFormatterPlugin {
    enabled: bool,
}

impl Plugin for JsonFormatterPlugin {
    fn metadata(&self) -> PluginMetadata {
        PluginMetadata {
            name: "JSON Formatter".to_string(),
            version: "1.0.0".to_string(),
            author: "iShell Team".to_string(),
            description: "Automatically detect and format JSON output".to_string(),
            capabilities: vec![PluginCapability::OutputFilter],
        }
    }
    
    fn on_load(&mut self, _context: &PluginContext) -> Result<()> {
        println!("JSON Formatter plugin loaded");
        self.enabled = true;
        Ok(())
    }
    
    fn on_unload(&mut self) -> Result<()> {
        println!("JSON Formatter plugin unloaded");
        Ok(())
    }
    
    fn on_ssh_output(&mut self, output: &str) -> Option<String> {
        if !self.enabled {
            return None;
        }
        
        // å°è¯•è§£æä¸º JSON
        if let Ok(value) = serde_json::from_str::<serde_json::Value>(output) {
            // ç¾åŒ– JSON
            if let Ok(pretty) = serde_json::to_string_pretty(&value) {
                return Some(pretty);
            }
        }
        
        None
    }
}

#[no_mangle]
pub extern "C" fn create_plugin() -> *mut dyn Plugin {
    Box::into_raw(Box::new(JsonFormatterPlugin { enabled: false }))
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ç®¡ç†

#### æ ‡ç­¾é¡µä¼‘çœ 
```rust
impl Tab {
    /// ä¼‘çœ ä¸æ´»è·ƒçš„æ ‡ç­¾é¡µ
    pub fn hibernate(&mut self) {
        if self.last_active.elapsed().unwrap() > Duration::from_secs(300) {
            // 5åˆ†é’Ÿæœªæ´»è·ƒï¼Œé‡Šæ”¾éƒ¨åˆ†èµ„æº
            self.state.terminal_output.shrink_to_fit();
            self.state.ai_messages.shrink_to_fit();
        }
    }
}
```

#### è¾“å‡ºç¼“å†²åŒºé™åˆ¶
```rust
const MAX_TERMINAL_OUTPUT: usize = 100_000; // 100KB

impl TabState {
    pub fn append_output(&mut self, output: &str) {
        self.terminal_output.push_str(output);
        
        // é™åˆ¶ç¼“å†²åŒºå¤§å°
        if self.terminal_output.len() > MAX_TERMINAL_OUTPUT {
            let trim_point = self.terminal_output.len() - MAX_TERMINAL_OUTPUT;
            self.terminal_output = self.terminal_output[trim_point..].to_string();
        }
    }
}
```

### 2. UI æ€§èƒ½

#### è™šæ‹Ÿæ»šåŠ¨
```rust
// åªæ¸²æŸ“å¯è§çš„ç»ˆç«¯è¡Œ
fn render_terminal_output(ui: &mut egui::Ui, output: &str) {
    let lines: Vec<&str> = output.lines().collect();
    let visible_height = ui.available_height();
    let line_height = 14.0;
    let visible_lines = (visible_height / line_height) as usize + 1;
    
    egui::ScrollArea::vertical().show_rows(
        ui,
        line_height,
        lines.len(),
        |ui, row_range| {
            for i in row_range {
                if let Some(line) = lines.get(i) {
                    ui.label(*line);
                }
            }
        },
    );
}
```

### 3. å¹¶å‘ä¼˜åŒ–

#### çº¿ç¨‹æ± 
```rust
use rayon::ThreadPoolBuilder;

pub struct AppRuntime {
    thread_pool: rayon::ThreadPool,
}

impl AppRuntime {
    pub fn new() -> Self {
        let thread_pool = ThreadPoolBuilder::new()
            .num_threads(num_cpus::get())
            .build()
            .unwrap();
        
        Self { thread_pool }
    }
    
    pub fn spawn_task<F>(&self, task: F)
    where
        F: FnOnce() + Send + 'static,
    {
        self.thread_pool.spawn(task);
    }
}
```

---

## ğŸ§ª æµ‹è¯•æ¡†æ¶

### å•å…ƒæµ‹è¯•

```rust
// src/tabs/manager.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_create_tab() {
        let mut manager = TabManager::new();
        assert_eq!(manager.tabs.len(), 1);
        
        manager.create_tab("Test".to_string(), None);
        assert_eq!(manager.tabs.len(), 2);
        assert_eq!(manager.active_tab_index, 1);
    }
    
    #[test]
    fn test_close_tab() {
        let mut manager = TabManager::new();
        manager.create_tab("Tab 2".to_string(), None);
        manager.create_tab("Tab 3".to_string(), None);
        
        assert!(manager.close_tab(1));
        assert_eq!(manager.tabs.len(), 2);
    }
    
    #[test]
    fn test_cannot_close_last_tab() {
        let mut manager = TabManager::new();
        assert!(!manager.close_tab(0));
        assert_eq!(manager.tabs.len(), 1);
    }
}
```

### é›†æˆæµ‹è¯•

```rust
// tests/tab_integration.rs
#[tokio::test]
async fn test_multi_tab_concurrent_ssh() {
    let mut app = create_test_app();
    
    // åˆ›å»º 3 ä¸ªæ ‡ç­¾é¡µ
    for i in 1..=3 {
        app.tab_manager.create_tab(format!("Tab {}", i), None);
    }
    
    // æ¨¡æ‹Ÿå¹¶å‘ SSH è¿æ¥
    let handles: Vec<_> = (0..3)
        .map(|i| {
            tokio::spawn(async move {
                // è¿æ¥åˆ°æµ‹è¯• SSH æœåŠ¡å™¨
                connect_to_test_server(i).await
            })
        })
        .collect();
    
    for handle in handles {
        assert!(handle.await.is_ok());
    }
}
```

---

## ğŸ“ é…ç½®æ–‡ä»¶æ‰©å±•

### v1.0.0 é…ç½®æ ¼å¼

```toml
version = "1.0.0"

# æ ‡ç­¾é¡µè®¾ç½®
[tabs]
max_tabs = 50
auto_restore_tabs = true
show_tab_icons = true

# ç«¯å£è½¬å‘é¢„è®¾
[[port_forwards]]
name = "MySQL Tunnel"
type = "local"
local_port = 3306
remote_host = "db.internal"
remote_port = 3306
auto_start = true

[[port_forwards]]
name = "SOCKS Proxy"
type = "dynamic"
local_port = 1080
auto_start = false

# æ’ä»¶é…ç½®
[plugins]
enabled = true
auto_load = true
plugin_dir = "~/.ishell/plugins"

[[plugins.installed]]
name = "json-formatter"
enabled = true
version = "1.0.0"

# SSH ä»£ç†é…ç½®ç¤ºä¾‹
[[connections]]
name = "Production DB"
host = "prod-db.internal"
port = 3306
username = "admin"

[connections.proxy]
jump_host = "bastion.company.com"
jump_port = 22
jump_username = "john"
jump_auth = { type = "key", key_path = "~/.ssh/id_rsa" }
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2026-02-03
